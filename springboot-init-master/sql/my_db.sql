/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3307
 Source Server Type    : MySQL
 Source Server Version : 80100
 Source Host           : localhost:3307
 Source Schema         : my_db

 Target Server Type    : MySQL
 Target Server Version : 80100
 File Encoding         : 65001

 Date: 05/10/2023 15:42:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for post
-- ----------------------------
DROP TABLE IF EXISTS `post`;
CREATE TABLE `post`
(
    `id`         bigint                                                         NOT NULL AUTO_INCREMENT COMMENT 'id',
    `title`      varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NULL     DEFAULT NULL COMMENT '标题',
    `content`    text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci          NULL COMMENT '内容',
    `tags`       varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL     DEFAULT NULL COMMENT '标签列表（json 数组）',
    `thumbNum`   int                                                            NOT NULL DEFAULT 0 COMMENT '点赞数',
    `favourNum`  int                                                            NOT NULL DEFAULT 0 COMMENT '收藏数',
    `userId`     bigint                                                         NOT NULL COMMENT '创建用户 id',
    `createTime` datetime                                                       NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `updateTime` datetime                                                       NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `isDelete`   tinyint                                                        NOT NULL DEFAULT 0 COMMENT '是否删除',
    PRIMARY KEY (`id`) USING BTREE,
    INDEX `idx_userId` (`userId` ASC) USING BTREE
) ENGINE = InnoDB
  AUTO_INCREMENT = 1709836534859780101
  CHARACTER SET = utf8mb4
  COLLATE = utf8mb4_unicode_ci COMMENT = '帖子'
  ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of post
-- ----------------------------
INSERT INTO `post`
VALUES (1708393118779125761, 'mygo', '喜欢mygo', '[\"mygo\",\"ano\"]', 0, 0, 1708383693301428225, '2023-10-01 16:07:14',
        '2023-10-01 16:07:14', 0);
INSERT INTO `post`
VALUES (1708393204380676098, '终将', '喜欢终将', '[\"终将\",\"仙贝\"]', 0, 0, 1708383693301428225,
        '2023-10-01 16:07:34', '2023-10-01 16:07:34', 0);
INSERT INTO `post`
VALUES (1708393282113712130, '跃动青春', '喜欢跃动青春', '[\"跃动\",\"青春\"]', 0, 0, 1708383693301428225,
        '2023-10-01 16:07:53', '2023-10-01 16:07:53', 0);
INSERT INTO `post`
VALUES (1708819065512726529, '跃动青春2', '喜欢跃动青春2', '[\"跃动\",\"青春\"]', 0, 0, 1708383693301428225,
        '2023-10-02 20:19:48', '2023-10-02 20:19:48', 0);
INSERT INTO `post`
VALUES (1709384562532777986, '前端页面渲染策略：SSR CSR ISR SSG', '29174423C26554E5B8A57D82CB5B', '[\"文章\",\"前端\"]',
        0, 0, 1708383693301428225, '2023-10-04 09:46:53', '2023-10-05 11:30:32', 0);
INSERT INTO `post`
VALUES (1709384562658607106, 'JavaWeb项目', '# javaweb-sixseven', '[\"文章\",\"项目\",\"Java\"]', 0, 0,
        1708383693301428225, '2023-10-04 09:46:53', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709384562658607107, 'Java -Servlet和Json', '## servlet```', '[\"文章\",\"Java\",\"后端\"]', 0, 0,
        1708383693301428225, '2023-10-04 09:46:53', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709384562658607108, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1708383693301428225, '2023-10-04 09:46:53', '2023-10-04 21:07:11', 0);
INSERT INTO `post`
VALUES (1709384562658607109, '网络编程,前端CRURD,服务器', '## 前端views开发简单CURD录', '[\"文章\"]', 0, 0,
        1708383693301428225, '2023-10-04 09:46:53', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709384562658607110, 'Vue-路由-生命周期-组件',
        '通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1708383693301428225, '2023-10-04 09:46:53', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709384562725715969, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1708383693301428225, '2023-10-04 09:46:53', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709384562725715970, 'JavaScript-Vue', '# 前端视图开发:\n', '[\"文章\",\"Vue\",\"NodeJS\"]', 0, 0,
        1708383693301428225, '2023-10-04 09:46:53', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709770438576263170, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 11:20:13', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709770438668537858, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 11:20:13', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709770438668537859, 'JavaWeb项目', '# javaweb-sixseven\n### 介绍：\n', '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1,
        '2023-10-05 11:20:13', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709770438668537860, 'Java -Servlet和Json', '## servlet\n```', '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1,
        '2023-10-05 11:20:13', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709770438668537861, '求大佬帮看看简历', '写简历好难啊、、、、', '[\"文章\"]', 0, 0, 1, '2023-10-05 11:20:13',
        '2023-10-05 11:32:36', 0);
INSERT INTO `post`
VALUES (1709770438668537862, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录', '[\"文章\"]', 0, 0, 1,
        '2023-10-05 11:20:13', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709770438668537863, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 11:20:13', '2023-10-05 11:25:53', 0);
INSERT INTO `post`
VALUES (1709770438668537864, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 11:20:13', '2023-10-05 11:40:53', 0);
INSERT INTO `post`
VALUES (1709770651164561409, '前端构建工具 ：SWC', 'test update', '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 11:21:03',
        '2023-10-05 11:38:32', 0);
INSERT INTO `post`
VALUES (1709826517834223617, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826517897138177, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826517897138178, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826517897138179, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826517897138180, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826517897138181, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826517897138182, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826517897138183, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:03:03', '2023-10-05 15:03:03', 0);
INSERT INTO `post`
VALUES (1709826826484666370, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709826826484666371, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709826826484666372, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709826826547580929, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709826826547580930, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709826826547580931, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709826826547580932, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709826826547580933, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:04:17', '2023-10-05 15:04:17', 0);
INSERT INTO `post`
VALUES (1709827009192742913, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827009192742914, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827009192742915, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827009192742916, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827009192742917, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827009192742918, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827009259851777, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827009259851778, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:00', '2023-10-05 15:05:00', 0);
INSERT INTO `post`
VALUES (1709827048950550529, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827048950550530, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827048950550531, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827048950550532, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827048950550533, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827048950550534, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827048950550535, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827048950550536, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:10', '2023-10-05 15:05:10', 0);
INSERT INTO `post`
VALUES (1709827126230601730, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709827126230601731, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709827126230601732, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709827126230601733, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709827126230601734, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709827126230601735, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709827126230601736, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709827126230601737, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:05:28', '2023-10-05 15:05:28', 0);
INSERT INTO `post`
VALUES (1709830621004386306, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709830621004386307, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709830621004386308, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709830621004386309, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709830621004386310, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709830621004386311, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709830621004386312, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709830621004386313, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:19:21', '2023-10-05 15:19:21', 0);
INSERT INTO `post`
VALUES (1709836303631994882, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836303631994883, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836303631994884, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836303631994885, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836303631994886, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836303631994887, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836303631994888, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836303631994889, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:41:56', '2023-10-05 15:41:56', 0);
INSERT INTO `post`
VALUES (1709836534859780098, '前端构建工具 ：SWC',
        '> 官网： https://swc.rs/\n\n### 简介\n\n官方：SWC 是一个基于 Rust 的可扩展平台，适用于下一代快速开发工具。SWC 可用于编译和捆绑。对于编译，它使用现代 JavaScript 功能获取 JavaScript / TypeScript 文件，并输出所有主要浏览器支持的有效代码。这里的编译和捆绑是：\n\n#### 编译 （ Compilation )\n\n- 编译是指将人类可读的源代码（例如 JavaScript 或 TypeScript）转换为计算机可执行的机器代码或中间代码的过程。\n- 在前端开发中，编译通常是**将高级语言（如 TypeScript）或新标准的 JavaScript（如 ES6+）转换为较旧版本的 JavaScript，以确保代码在不同浏览器和环境中都能正常运行**。\n- SWC 用于加速这个编译过程，特别是当需要将较新的 JavaScript 特性编译为浏览器支持的 JavaScript。\n\n#### 捆绑 （ Bundling )\n\n- 捆绑是指将多个模块或文件组合成一个或多个单一的文件（通常是 JavaScript 文件）的过程，以便在浏览器中加载和执行。\n- 在现代前端开发中，应用程序通常由多个模块和依赖组成，这些模块可能分散在不同的文件中。捆绑工具（如Webpack、Parcel、Rollup等）负责将这些文件捆绑成一个或多个最终可执行的文件。\n- 捆绑的目的是**减少网络请求次数和提高加载性能，因为浏览器加载单个捆绑文件要比加载多个小文件更高效**。\n- SWC 在捆绑过程中可以被用来编译和优化 JavaScript/TypeScript 代码，以提高捆绑后应用程序的性能。\n\n​	所以，它就是把我们的代码转为游览器或者其他平台识别的代码，和它的竞品有 esbuild 和 babel，目前主流使用的还是 babel，因为它安全，兼容性好，\n\n### 参考\n\n1. SWC 和 babel 对比：https://juejin.cn/post/7136404050995576863#comment\n2. SWC基本使用：https://zhuanlan.zhihu.com/p/437529362\n3. SWC 和 ESBuild 对比：https://juejin.cn/post/7091655236938366989\n\n\n\n\n\n',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);
INSERT INTO `post`
VALUES (1709836534859780099, '前端页面渲染策略：SSR CSR ISR SSG',
        '### 为什么会产生很多页面渲染策略？\n\n因为不同的项目和需求需要不同的优化和处理手段。例如：\n\n- 一些网站可能会更关心SEO，\n- 一些可能更关心性能或者数据的实时性。\n\n以下是我对上述每种策略以及它们的适用场景的更深入的解释：\n\n### SSR\n\n> Server Side Rendering : 服务端渲染\n\n在这种方式下，当您请求一个网页时，服务器会为每个请求生成一个新的 HTML 页面。这意味着每次点击，都会发送一个新的请求到服务器，然后服务器动态生成新的 HTML。它能更好的支持搜索引擎优化（SEO），并且首屏加载速度比CSR更快，但同时服务器压力较大。\n\n特点：\n\n- 用户体验友好，\n- 首屏加载速度快，\n- 消耗服务器资源，\n\n使用场景：需要快速首次绘制和优秀的SEO的应用或网站，需要搜索引擎能很好地分析其文本以优化搜索结果\n\n- 新闻网站、\n- 博客、\n- 电子商务网站等\n\n#### 实现方式\n\n**React**\n\n- Nextjs 13 现在创建的已经默认是 【服务端组件】 了\n\n**Vue**\n\n- Nuxt 没有使用过，参考文章：https://juejin.cn/post/7170746000112353293\n\n### CSR\n\n> Client Side Rendering： 客户端渲染，也是我们最常用的，例如单页面应用\n\n在这种方式下，服务器仅在首次访问时返回一个最基本的页面框架，然后通过 JavaScript 在客户端动态生成页面内容。随后的页面交互都不需要服务器参与，降低服务器压力和网络带宽消耗，提升页面响应速度。但首屏渲染时间较长，并且搜索引擎优化复杂。\n\n特点：\n\n- 服务端压力小\n- SEO 困难\n- 适用交互多，内容动态更新多\n\n使用场景：许多功能可能需要前端 JavaScript 动态处理和操作 DOM\n\n- 单页面应用（SPA）\n- 复杂的Web应用\n- 在线编辑器等\n\n#### 实现方式\n\n- React：开发的单页面应用程序就是\n- vue：开发的单页面应用程序就是\n- umi：企业级框架实现方案\n\n### ISR\n\n> Incremental Static Regeneration：增量静态再生，\n\n这是 Next.js 引入的一种新方法，允许开发者在**构建时**生成和优化页面，构建完成后可以为每个页面创建一个静态的 HTML。当请求这个页面时，服务器会返回预构建的 HTML。但与 SSG 不同，ISR 可以在后台异步地更新已构建的页面，当页面数据更改时，不需要重新构建整个应用，而是只重新生成改变的部分。\n\n特点：\n\n- 大量内容不变\n- 部分需要实时更新\n\n使用场景：\n\n- 博客站点的网站（大部分仅在作者更新文章改编，少量需要实时更新，例如：访客留言）\n\n#### 实现方式\n\n- Nextjs\n- Nuxt\n\n### SSG\n\n> Static Site Generation 静态网站生成\n\n在**构建时间**，生成每个页面的静态HTML，同一页面的每个请求，都将返回构建时生成的相同HTML。这样可以提供非常高的性能和安全性，但它不适用于内容经常改变的站点，因为内容的每次更改都需要重新构建整个站点。\n\n特点：\n\n- 内容稳定\n- 不经常更新\n- 速度快，安全高\n\n使用场景：\n\n- 官方文档\n- blog\n- 销售页面\n\n#### 实现方式\n\n- [Jekyll](https://www.jekyll.com.cn/): 最早也是最流行的静态站点生成器之一，由 Github 的创始人开发。它支持 Markdown、Liquid 模板语言，你可以在 Github Pages 上免费托管 Jekyll 生成的网站。\n- [Hugo](https://gohugo.io/): 另一个广受欢迎的静态网站生成器，它使用 Go 语言编写，所以速度非常快。Hugo 提供一些强大的功能，例如内置的 Disqus 评论系统和自定义 URL。\n- [Gatsby](https://www.gatsbyjs.com/): Gatsby 不仅仅是静态站点生成器，它实际上是一个用于构建前端 web 应用程序的强大框架。Gatsby 使用 React 和 GraphQL，预配置以优化网站的速度和性能。\n- [Next.js](https://nextjs.org/): 当使用 Next.js 的静态导出功能时，Next.js 也可以作为静态页面生成器来使用。Next.js 提供了基于 React 的高级特性，如服务端渲染和静态站点生成。\n- [Hexo](https://hexo.io/index.html): 简单快速的静态博客框架，主要面向博客类型的静态网站，对 Markdown 支持良好，拥有丰富的主题和插件。\n- [Nuxt.js](https://www.nuxtjs.cn/)：Nuxt.js是最受欢迎的Vue静态网站生成器之一。它提供了一种简单的方法来为Vue应用程序添加服务端渲染，可以生成静态网站，同时支持单页面应用 (SPA)模式。\n- [VuePress](https://vuepress.vuejs.org/zh/)：VuePress是一个基于Vue的轻量级静态网站生成器。它的主要目标是为Vue及其子项目提供文档支持，但同时它也可以用来制作个人博客和其他内容驱动的网站。VuePress默认主题优化了文档阅读，并提供了针对内容的阅读时间估计、内置搜索和侧边栏链接等功能。\n- [Gridsome](https://www.gridsome.cn/)：Gridsome是受Gatsby启发的Vue.js的静态网站生成器。Gridsome用于构建高性能的、可扩展的、以Vue.js为基础的网站。支持热重载、服务器端渲染、代码拆分等特性。\n- [Saber.js](https://saber.egoist.dev/)：Saber是受Gatsby和Nuxt启发的一个极简静态网站生成器。同样用于构建高性能的、以Vue.js为基础的网站，并且对Markdown文件的支持做的很好。\n\n### prerendering\n\n> 预渲染\n\n预渲染在构建时生成网站的静态HTML版本，这对于那些对SEO有高要求、但又不需要服务器实时生成页面的项目来说是个不错的选择。\n\n#### 实现方式\n\n1. 静态网站生成器（Static Site Generators）：例如Nuxt.js、Next.js、Gatsby等框架在构建时会生成静态的HTML。这种方式的优点是这些框架通常包含大量的插件和配置，可以帮助我们简化预渲染的流程，缺点是因为页面在构建时生成，所以对于需要实时更新的网站可能就不太合适。\n2. Prerender SPA Plugin：这是一个用于预渲染单页应用（SPA）的 webpack 插件，它将在你的应用构建完毕后启动一个虚拟浏览器渲染你的应用并保存下这个 HTML。这种方法比较适用于页面不多且不需要经常更新的项目。\n3. Puppeteer：Puppeteer 是一个 Node.js 库，提供了一系列与 Chrome 或 Chromium 交互的 API，我们可以通过编程的方式控制 Chrome 或 Chromium，从而达到预渲染的目的。我们可以通过 Puppeteer 实现按需渲染，只有当用户请求一个页面的时候才去生成页面的 HTML，这在一些实时性要求较高、或者页面非常多的项目中十分有用。\n4. 在服务器端使用渲染引擎（如 PhantomJS 或 Headless Chrome 等）进行HTML快照，这种方式的优势在于实时性较好，劣势是会增加服务器的负载。\n\n以上，选择哪种方案最终还是要看你的项目需求，各种渲染方式也可以结合使用，选择最适合你的那种。\n\n### 参考\n\n1. 【掘金】前端渲染SSR、CSR、ISR、SSG的对比：https://juejin.cn/post/7202666869965897784\n2. 【掘金】nextjs 中的各种渲染：https://juejin.cn/post/7273674732447711295?searchId=20230929174423C26554E5B8A57D82CB5B',
        '[\"文章\",\"前端\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);
INSERT INTO `post`
VALUES (1709836534859780100, 'JavaWeb项目',
        '# javaweb-sixseven\n### 介绍：\n**一个纯原生的JavaWeb（servlet+jsp）商城项目** 涵盖了JavaWeb所有的知识点，包括：servlet、过滤器、监听器、线程、JDBC连接池技术、事务管理和自定义分页等知识。\n### 项目地址：https://gitee.com/shuaidaia/javaweb-sixseven.git\n\n#### 技术栈： \n前端：h5、c3、jq、ajax、jsp 后端：JavaWeb、mysql\n###### 项目功能模块：\n首页、商城、购物车、评论吧、订单信息和后台管理',
        '[\"文章\",\"项目\",\"Java\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);
INSERT INTO `post`
VALUES (1709836534859780101, 'Java -Servlet和Json',
        '## servlet\n\n### 网络请求和响应\n1. 请求方式\n ```text\n`get`和`post`的区别\n`get`请求: \n1. 请求参数在url中, \n2. 请求参数有长度限制\n3. 请求参数不安全\n4. 请求参数类型只能是`String`\n5. 可以缓存\n\n`post`\n1. 请求参数在请求体中\n2. 请求参数没有长度限制\n3. 请求参数安全\n4. 请求参数类型没有限制\n5. 不可以缓存\n```\n3. 状态码\n```text\n200: 请求成功\n302: 重定向\n404: 请求资源不存在\n500: 服务器内部错误\n```\n\n### 创建一个 Servlet\n1. 创建一个类, 继承 `HttpServlet` 类\n2. 重写 `service` 方法 参数为 `HttpServletRequest` 和 `HttpServletResponse`\n3. 在 `web.xml` 中配置 `servlet` 和 `servlet-mapping` 标签\n\n### servlet的生命周期\n1. 创建 `servlet` 对象\n2. 调用 `init` 方法\n3. 调用 `service` 方法\n4. 调用 `destroy` 方法\n5. 销毁 `servlet` 对象\n6. `servlet` 对象被垃圾回收器回收\n\n\n#### LoadOnStartup\n1. `LoadOnStartup` 标签的作用是在服务器启动时就创建 `servlet` 对象\n2. `LoadOnStartup` 标签的值越小, 优先级越高\n3. `LoadOnStartup` 标签的值为负数时, 表示在第一次访问时创建 `servlet` 对象\n\n\n### Json 格式数据\n1. Json 和 XML 的区别\n```text\n1. Json 的数据量比 XML 小\n2. Json 的解析速度比 XML 快\n3. Json 的数据格式比 XML 简单\n```\n2. Json 的数据格式\n\n   1. 对象: {\"name\": \"张三\", \"age\": 18}\n   2. 数组: [{\"name\": \"张三\", \"age\": 18}, {\"name\": \"李四\", \"age\": 19}]\n   3. 对象引用: {\"name\": \"张三\", \"age\": 18, \"friend\": {\"name\": \"李四\", \"age\": 19}}\n### Json 的解析\n1.Js和Json的相互转换\n```text\n1. JSON.stringify(js对象) 将js对象转换为json字符串\n2. JSON.parse(json字符串) 将json字符串转换为js对象\n```\n2. Java中的Json的相互转换\n- jackson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入jackson的jar包\n   2. 创建ObjectMapper对象\n   3. 调用writeValueAsString方法 如: objectMapper.writeValueAsString(user)\n\n2. 将json字符串转换为java对象\n    1. 导入jackson的jar包\n    2. 创建ObjectMapper对象\n    3. 调用readValue方法 如: objectMapper.readValue(json字符串, User.class)\n```\n- fastjson的使用\n```text\n1. 将java对象转换为json字符串\n   1. 导入fastjson的jar包\n   2. 调用toJSONString方法 如: JSON.toJSONString(user)\n2. 将json字符串转换为java对象\n   1. 导入fastjson的jar包\n   2. 调用parseObject方法 如: JSON.parseObject(json字符串, User.class)\n```',
        '[\"文章\",\"Java\",\"后端\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);
INSERT INTO `post`
VALUES (1709836534859780102, '求大佬帮看看简历',
        '\n\n![国企简历1_00(1).png](https://pic.code-nav.cn/post_picture/1678008113959014401/e5Qx1keN-国企简历1_00(1).png)\n\n![国企简历1_01.png](https://pic.code-nav.cn/post_picture/1678008113959014401/BJ4KlWxL-国企简历1_01.png)\n![简历_00.png](https://pic.code-nav.cn/post_picture/1678008113959014401/go8pF43u-简历_00.png)',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);
INSERT INTO `post`
VALUES (1709836534859780103, '网络编程,前端CRURD,服务器',
        '## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n  data() {\n    return {\n      tableData: [{\n        date: \'2016-05-02\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1518 弄\'\n      }, {\n        date: \'2016-05-04\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1517 弄\'\n      }, {\n        date: \'2016-05-01\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1519 弄\'\n      }, {\n        date: \'2016-05-03\',\n        name: \'王小虎\',\n        address: \'上海市普陀区金沙江路 1516 弄\'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);
INSERT INTO `post`
VALUES (1709836534859780104, 'Vue-路由-生命周期-组件',
        '## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​		1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​		2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​		1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​		2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​		1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​		 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: \'Hello, Vue!\',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log(\'beforeCreate\');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log(\'created\');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log(\'beforeMount\');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log(\'mounted\');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log(\'beforeUpdate\');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log(\'updated\');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log(\'beforeDestroy\');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log(\'destroyed\');\n    },\n    methods: {\n      updateMessage() {\n        this.message = \'Updated Message\';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from \'vue\';\nimport VueRouter from \'vue-router\';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: \'/\', component: Home },\n    { path: \'/about\', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount(\'#app\');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: \'/about\', component: () => import(\'./About.vue\') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `\'hash\'`（哈希模式）或 `\'history\'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push(\'/home\'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace(\'/about\'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: \'/about\' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push(\'/home\')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: \'/home\',\n  query: { key: \'value\' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push(\'/home\');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: \'/about\', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: \'user\', params: { id: 1 } });  // 跳转到命名为 \'user\'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace(\'/home\');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: \'/about\', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: \'user\', params: { id: 1 } });  // 替换当前路由为命名为 \'user\'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: \'home\' });  // 跳转到名称为 \'home\' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: \'about\', query: { id: 1 } });  // 跳转到名称为 \'about\' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: \'routeName\' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: \'home\' }\">Home</router-link>\n<router-link :to=\"{ name: \'about\' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: \'/path\', query: { param1: \'value1\', param2: \'value2\' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: \'/home\'\n  },\n  {\n    path: \'/home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: \'/\',\n    redirect: { name: \'home\' }\n  },\n  {\n    path: \'/home\',\n    name: \'home\',\n    component: Home\n  },\n  {\n    path: \'/about\',\n    name: \'about\',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: \'/product/:id\',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === \'1\') {\n        return \'/product-a\';  // 重定向到 /product-a\n      } else {\n        return \'/product-b\';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);
INSERT INTO `post`
VALUES (1709836534935277569, 'MySQL常见的性能优化方法技巧以及示例',
        'MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n',
        '[\"文章\"]', 0, 0, 1, '2023-10-05 15:42:51', '2023-10-05 15:42:51', 0);

-- ----------------------------
-- Table structure for post_favour
-- ----------------------------
DROP TABLE IF EXISTS `post_favour`;
CREATE TABLE `post_favour`
(
    `id`         bigint   NOT NULL AUTO_INCREMENT COMMENT 'id',
    `postId`     bigint   NOT NULL COMMENT '帖子 id',
    `userId`     bigint   NOT NULL COMMENT '创建用户 id',
    `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    INDEX `idx_postId` (`postId` ASC) USING BTREE,
    INDEX `idx_userId` (`userId` ASC) USING BTREE
) ENGINE = InnoDB
  CHARACTER SET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci COMMENT = '帖子收藏'
  ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of post_favour
-- ----------------------------

-- ----------------------------
-- Table structure for post_thumb
-- ----------------------------
DROP TABLE IF EXISTS `post_thumb`;
CREATE TABLE `post_thumb`
(
    `id`         bigint   NOT NULL AUTO_INCREMENT COMMENT 'id',
    `postId`     bigint   NOT NULL COMMENT '帖子 id',
    `userId`     bigint   NOT NULL COMMENT '创建用户 id',
    `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    INDEX `idx_postId` (`postId` ASC) USING BTREE,
    INDEX `idx_userId` (`userId` ASC) USING BTREE
) ENGINE = InnoDB
  CHARACTER SET = utf8mb4
  COLLATE = utf8mb4_0900_ai_ci COMMENT = '帖子点赞'
  ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of post_thumb
-- ----------------------------

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`
(
    `id`           bigint                                                         NOT NULL AUTO_INCREMENT COMMENT 'id',
    `userAccount`  varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NOT NULL COMMENT '账号',
    `userPassword` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NOT NULL COMMENT '密码',
    `unionId`      varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NULL     DEFAULT NULL COMMENT '微信开放平台id',
    `mpOpenId`     varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NULL     DEFAULT NULL COMMENT '公众号openId',
    `userName`     varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NULL     DEFAULT NULL COMMENT '用户昵称',
    `userAvatar`   varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL     DEFAULT NULL COMMENT '用户头像',
    `userProfile`  varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NULL     DEFAULT NULL COMMENT '用户简介',
    `userRole`     varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci  NOT NULL DEFAULT 'user' COMMENT '用户角色：user/admin/ban',
    `createTime`   datetime                                                       NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `updateTime`   datetime                                                       NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `isDelete`     tinyint                                                        NOT NULL DEFAULT 0 COMMENT '是否删除',
    PRIMARY KEY (`id`) USING BTREE,
    INDEX `idx_unionId` (`unionId` ASC) USING BTREE
) ENGINE = InnoDB
  AUTO_INCREMENT = 1709396400460898306
  CHARACTER SET = utf8mb4
  COLLATE = utf8mb4_unicode_ci COMMENT = '用户'
  ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user`
VALUES (1708383693301428225, '123123', '1e6329b50592eccce486b8eba229504b', NULL, NULL, '迅迅子', NULL, NULL, 'admin',
        '2023-10-01 15:29:47', '2023-10-04 10:31:22', 0);
INSERT INTO `user`
VALUES (1709396298056966145, '18023664487', '1e6329b50592eccce486b8eba229504b', NULL, NULL, '醒酒器', NULL, NULL,
        'user', '2023-10-04 10:33:31', '2023-10-04 10:34:21', 0);
INSERT INTO `user`
VALUES (1709396347952406529, '314314314', '1e6329b50592eccce486b8eba229504b', NULL, NULL, '小鹤', NULL, NULL, 'user',
        '2023-10-04 10:33:43', '2023-10-04 10:34:14', 0);
INSERT INTO `user`
VALUES (1709396370664562689, '226226226', '1e6329b50592eccce486b8eba229504b', NULL, NULL, '小炫', NULL, NULL, 'user',
        '2023-10-04 10:33:48', '2023-10-04 10:34:26', 0);
INSERT INTO `user`
VALUES (1709396400460898305, '102810281028', '1e6329b50592eccce486b8eba229504b', NULL, NULL, '小🐟', NULL, NULL, 'user',
        '2023-10-04 10:33:55', '2023-10-04 10:34:38', 0);

SET FOREIGN_KEY_CHECKS = 1;
